states_map <- map_data("state")
crowdestimates_raw_count_map <-
ggplot(crowdestimates_state,
aes(map_id = state)) +
geom_map(aes(fill = state_total),
map = states_map)  +
scale_fill_viridis(option = "plasma") +
expand_limits(x = states_map$long,
y = states_map$lat) +
coord_map() +
theme_bw() +
ggtitle("Women's March, Jan 2017: \nCounts of people participating by state",
subtitle = paste0("Data collected by \n",  data_collectors)) +
labs(caption = paste0("R code online at \n", code_gist))
#  basic map of proprtion of state population
library(choroplethr) # has state population data
data(df_pop_state) # 2012 estimate
crowdestimates_state_prop <-
crowdestimates_state %>%
left_join(df_pop_state,
by = c("state" = "region")) %>%
mutate(mean_estimate_prop = state_total / value)
crowdestimates_prop_count_map <-
ggplot(crowdestimates_state_prop,
aes(map_id = state)) +
geom_map(aes(fill = mean_estimate_prop),
map = states_map)  +
scale_fill_viridis(option = "plasma") +
expand_limits(x = states_map$long,
y = states_map$lat) +
theme_bw()  +
coord_map() +
ggtitle("Women's March, Jan 2017: \nProportion of state population participating",
subtitle = paste0("Data collected by \n",  data_collectors)) +
labs(caption = paste0("R code online at ", code_gist))
#  ------------------------------------------------------------------------
# County-level maps
# Basic city-level map, using county populations
# here are the county polygons for the map
counties_map <- map_data("county")
counties_map$county <- counties_map$subregion
# get county names and FIPS codes
library(maps)
data(county.fips)
# gives us FIPS, state and county names
county_fips <-
county.fips %>%
separate(polyname, c("state", "county"), ",") %>%
left_join(counties_map,
by = c("county" = "subregion")) %>%
distinct(fips, state, county)
# gives us city names, states, & county FIPS for a city (but not county names)
library(noncensus)
data(zip_codes)
zip_codes_county_fips <-
zip_codes %>%
mutate(state = ifelse(state == "OR" & city == "Walla Walla", "WA", state)) %>%
mutate(city = tolower(city)) %>%
dplyr::select(-zip, -latitude, -longitude)
# get county and city names, and county FIPS, and county populations
data(df_county_demographics) # get populations for counties, about 3,144 of them
county_city_fips_map_pops <-
df_county_demographics %>%
left_join(county_fips,
by = c("region" = "fips"))  %>%
left_join(zip_codes_county_fips,
by = c("region" = "fips")) %>%
distinct(city, county, state.y, region, total_population) %>%
mutate(city = ifelse(city == "parcel return service" & state.y == "DC", "washington", city)) %>%
arrange(city, county)
# join county name and population data to crowd data
crowdestimates_sep_county <-
crowdestimates_sep %>%
mutate(state = state_abb) %>%
left_join(county_city_fips_map_pops,
by = c("city", "state_abb" = "state.y" )) %>%
mutate(prop_county = mean_estimate / total_population) %>%
filter(!is.na(mean_estimate)) %>%
filter(state %in% state.abb)
# some cities join with more than one county
# just get the one with the highest prop
# for simplicity. This could be an error-introducing
# step, probably checking each duplicate by
# hand would be better
crowdestimates_sep_per_county <-
crowdestimates_sep_county %>%
group_by(city, county, state) %>%
dplyr::summarise(prop_county = max(prop_county)) %>%
left_join(crowdestimates_sep_county) %>%
ungroup() %>%
mutate(county = gsub(":.*", "", county)) %>%
filter(!is.na(county))
# join with other counties we don't have data for
# that can show on the map instead of a hole
crowdestimates_sep_per_county_all_counties <-
crowdestimates_sep_per_county %>%
right_join(counties_map,
by = c("county" = "subregion"))
# plot raw counts for counties, we'll use the log values because of the huge range in county-level march attendence.
crowdestimates_county_raw_count_map <-
ggplot() +
geom_polygon(data = crowdestimates_sep_per_county_all_counties,
colour = "grey40",
aes(long,
lat,
group = group,
fill = log(mean_estimate)))  +
scale_fill_viridis(option = "plasma") +
coord_map() +
theme_bw()  +
ggtitle("Women's March, Jan 2017: \nCount of participants by county",
subtitle = paste0("Data collected by \n",  data_collectors)) +
labs(caption = paste0("R code online at ", code_gist))
# plot proportion of county pop for counties
crowdestimates_county_prop_map <-
ggplot() +
geom_polygon(data = crowdestimates_sep_per_county_all_counties,
colour = "grey40",
aes(long,
lat,
group = group,
fill = log(prop_county)))  +
scale_fill_viridis(option = "plasma") +
coord_map() +
theme_bw()  +
ggtitle("Women's March, Jan 2017: \nProportion of county population participating",
subtitle = paste0("Data collected by \n",  data_collectors)) +
labs(caption = paste0("R code online at ", code_gist))
# Copyright 2017 Ben Marwick
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
crowdestimates_raw_count_map
crowdestimates_state
crowdestimates
View(crowdestimates)
crowdestimates_sep <-
crowdestimates %>%
separate(A, c("city", "state_abb"), sep = ", ") %>%
mutate(lower = as.numeric(gsub(",", "", D)),
upper = as.numeric(gsub(",", "", E)),
city = tolower(city),
state_abb = toupper(state_abb)) %>%
rowwise() %>%
dplyr::mutate(mean_estimate = mean(c(lower, upper), na.rm = TRUE))
crowdestimates_sep
us_locations <-
crowdestimates_sep %>%
filter(state_abb %in% state.abb) %>%
filter(mean_estimate > 0) %>%
nrow
us_locations
crowdestimates_state <-
crowdestimates_sep %>%
right_join(data_frame(state_abb = state.abb,
state = tolower(state.name))) %>%
group_by(state_abb, state) %>%
dplyr::summarise(state_total = sum(mean_estimate, na.rm = TRUE))
library(viridis)
states_map <- map_data("state")
crowdestimates_raw_count_map <-
ggplot(crowdestimates_state,
aes(map_id = state)) +
geom_map(aes(fill = state_total),
map = states_map)  +
scale_fill_viridis(option = "plasma") +
expand_limits(x = states_map$long,
y = states_map$lat) +
coord_map() +
theme_bw() +
ggtitle("Women's March, Jan 2017: \nCounts of people participating by state",
subtitle = paste0("Data collected by \n",  data_collectors)) +
labs(caption = paste0("R code online at \n", code_gist))
crowdestimates_raw_count_map
library(choroplethr) # has state population data
data(df_pop_state) # 2012 estimate
crowdestimates_state_prop <-
crowdestimates_state %>%
left_join(df_pop_state,
by = c("state" = "region")) %>%
mutate(mean_estimate_prop = state_total / value)
crowdestimates_prop_count_map <-
ggplot(crowdestimates_state_prop,
aes(map_id = state)) +
geom_map(aes(fill = mean_estimate_prop),
map = states_map)  +
scale_fill_viridis(option = "plasma") +
expand_limits(x = states_map$long,
y = states_map$lat) +
theme_bw()  +
coord_map() +
ggtitle("Women's March, Jan 2017: \nProportion of state population participating",
subtitle = paste0("Data collected by \n",  data_collectors)) +
labs(caption = paste0("R code online at ", code_gist))
crowdestimates_prop_count_map
counties_map <- map_data("county")
counties_map$county <- counties_map$subregion
library(maps)
data(county.fips)
county_fips <-
county.fips %>%
separate(polyname, c("state", "county"), ",") %>%
left_join(counties_map,
by = c("county" = "subregion")) %>%
distinct(fips, state, county)
library(noncensus)
data(zip_codes)
zip_codes_county_fips <-
zip_codes %>%
mutate(state = ifelse(state == "OR" & city == "Walla Walla", "WA", state)) %>%
mutate(city = tolower(city)) %>%
dplyr::select(-zip, -latitude, -longitude)
data(df_county_demographics) # get populations for counties, about 3,144 of them
county_city_fips_map_pops <-
df_county_demographics %>%
left_join(county_fips,
by = c("region" = "fips"))  %>%
left_join(zip_codes_county_fips,
by = c("region" = "fips")) %>%
distinct(city, county, state.y, region, total_population) %>%
mutate(city = ifelse(city == "parcel return service" & state.y == "DC", "washington", city)) %>%
arrange(city, county)
crowdestimates_sep_county <-
crowdestimates_sep %>%
mutate(state = state_abb) %>%
left_join(county_city_fips_map_pops,
by = c("city", "state_abb" = "state.y" )) %>%
mutate(prop_county = mean_estimate / total_population) %>%
filter(!is.na(mean_estimate)) %>%
filter(state %in% state.abb)
crowdestimates_sep_per_county <-
crowdestimates_sep_county %>%
group_by(city, county, state) %>%
dplyr::summarise(prop_county = max(prop_county)) %>%
left_join(crowdestimates_sep_county) %>%
ungroup() %>%
mutate(county = gsub(":.*", "", county)) %>%
filter(!is.na(county))
crowdestimates_sep_per_county_all_counties <-
crowdestimates_sep_per_county %>%
right_join(counties_map,
by = c("county" = "subregion"))
crowdestimates_county_raw_count_map <-
ggplot() +
geom_polygon(data = crowdestimates_sep_per_county_all_counties,
colour = "grey40",
aes(long,
lat,
group = group,
fill = log(mean_estimate)))  +
scale_fill_viridis(option = "plasma") +
coord_map() +
theme_bw()  +
ggtitle("Women's March, Jan 2017: \nCount of participants by county",
subtitle = paste0("Data collected by \n",  data_collectors)) +
labs(caption = paste0("R code online at ", code_gist))
crowdestimates_county_raw_count_map
crowdestimates_county_prop_map
crowdestimates_sep_per_county_all_counties
crowdestimates_sep_per_county_all_counties$prop_county
crowdestimates_sep_county$mean_estimate
crowdestimates_sep_county$total_population
crowdestimates_county_raw_count_map
crowdestimates_sep_per_county_all_counties$prop_county
crowdestimates_county_prop_map <-
ggplot() +
geom_polygon(data = crowdestimates_sep_per_county_all_counties,
colour = "grey40",
aes(long,
lat,
group = group,
fill = log(prop_county)))  +
scale_fill_viridis(option = "plasma") +
coord_map() +
theme_bw()  +
ggtitle("Women's March, Jan 2017: \nProportion of county population participating",
subtitle = paste0("Data collected by \n",  data_collectors)) +
labs(caption = paste0("R code online at ", code_gist))
crowdestimates_county_prop_map
b <- scan()
b
fix()
ct <- read_excel("C:/Users/bmarwick/Downloads/Con-Chan-Tien.xlsx")
library(readxl)
ct <- read_excel("C:/Users/bmarwick/Downloads/Con-Chan-Tien.xlsx")
fix(ct)
edit(ct)
library(readxl)
ct <- read_excel("C:/Users/bmarwick/Downloads/Con-Chan-Tien.xlsx")
library(readxl)
ct <- read_excel("C:/Users/bmarwick/Downloads/Con-Chan-Tien.xlsx")
library(tidyverse)
ct <-
ct %>%
filter(!is.na(Mass)) %>%
filter(!is.na(Dai))
breaks <- seq(min(ct$Mass), max(ct$Mass), 100)
ct$bin <- findInterval(ct$Mass, breaks)
ct$start <- breaks[ct$bin]
ct$end <- breaks[ct$bin + 1]
ggplot(ct,
aes(Mass)) +
geom_density() +
geom_vline(xintercept = ct$start,
colour = "red")
ct <-
ct %>%
filter(!is.na(bin))
plot(cars)
plot(cars)
install.packages('rsconnect')
shiny::runApp('C:/Users/bmarwick/Desktop/Harvard_2017/scopusarchaeology/scopusarchaeology')
library(rsconnect)
rsconnect::setAccountInfo(name='benmarwick', token='52CBCB7E43BDC1CCBF5EF9E47C25C9DD', secret='yIeD/9hm05LK3walPGciGl9dXt80Yd10LieY7CMm')
install.packages("purrr")
install.packages("purrr")
install.packages("dplyr")
?titlePanel
??titlePanel
shiny::runApp('C:/Users/bmarwick/Desktop/Harvard_2017/scopusarchaeology/scopusarchaeology')
if (!require("ghit")) install.packages("ghit")
if (!require("ghit")) install.packages("ghit")
install.packages("plotly")
setwd("E:/My Documents/My Papers/conferences/SAA2017/SAA2017 R forum/Contreras")
# getting started: load necessary packages
require(rgdal)
require(raster)
require(rasterVis)
require(lattice)
#  	Import data - first a 30m DEM from NASA SRTM data (http://doi.org/10.5067/MEaSUREs/SRTM/SRTMGL1N.003) in geotiff format (though raster() will read any format that readGDAL() {rgdal} recognizes), and then a point shapefile (a standard ESRI .shp, though readOGR() {rgdal} can import many other sorts of spatial data also).
# commands: raster() {raster}, readOGR() {rgdal}
areaDEM <- raster("demo_files/areaDEM.tif")  # read raster
areaDEMutm <- projectRaster(areaDEM,
crs="+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0") # It will be easier to work with projected data, so we'll project this to UTM using the appropriate proj4 string (http://proj4.org/index.html) for the CRS (Coordinate Reference System) that we want.
areaDEMutm  #Have a quick look at this to make sure nothing has gone terribly wrong - with the raster package loaded typing the name of a raster object will give you summary data about that object.
sites <- readOGR(dsn="demo_files", layer="areaPoints") # read .shp (note that to read a shapefile, "the data source name (dsn= argument) is the folder (directory) where the shapefile is, and the layer is the name of the shapefile (without the .shp extension)" (from the readOGR {rgdal} documentation))
sites_sub <- sites[sites$period == "EIA" | sites$period == "GalRom",]  # subset points to eliminate sites of uncertain date - i.e., select from 'sites' only those rows in which the 'period' column is "EIA" or "GalRom".
sites_sub$period <- factor(sites_sub$period) #drop unused levels (not strictly necessary but will avoid messiness when plotting data later)
sites_sub_utm <- spTransform(sites_sub,
"+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0") # project points to UTM
sites_sub_utm  #Check the file (note that it is now a Spatial Points Data Frame, and typing its name will give you an object summary).  Note that there is a 'type' field that we won't work with here, but which could be incorporated into this kind of analysis, e.g., by further sub-setting or by grouping data when boxplotting.
#
# commands: terrain() {raster}
area_slope <- terrain(areaDEMutm, opt = 'slope', unit = 'degrees')  #calculate slope
area_aspect <- terrain(areaDEMutm, opt = 'aspect', unit = 'degrees') #calculate aspect
#Have a quick look at these to see that the results make sense - they are now raster objects just like areaDEM and can be examined the same way.
area_slope
area_aspect
#
# commands: levelplot() {rasterVis}, it's also a function in the lattice pkg, so let's specify the namespace just to be sure we are using the right function
rasterVis::levelplot(areaDEMutm,
margin = list(x = FALSE,
y = TRUE),
col.regions = terrain.colors(16),
xlab = list(label = "",
vjust = -0.25),
sub = list(
label = "masl",
font = 1,
cex = .9,
hjust = 1.5))
# commands: spplot() {sp}
rasterVis::levelplot(areaDEMutm,
margin = list(x = F,
y = T),
col.regions = terrain.colors(16),
xlab = list (label = "",
vjust = -.25),
sub = list(
label = "masl",
font = 1,
cex = .9,
hjust = 1.5),
key = list(       #this time we'll include a legend that identifies the points we'll plot
space = "top",
points = list(
pch = c(18,20),
col = c("red","blue")),
text = list(
c("EIA","GalRom"),
cex=.8))
) +
spplot(sites_sub_utm, # add a layer of points
zcol = "period",
cex = .6,
pch = c(18,20),
col.regions = c("red","blue")
)
# commands: stack() {raster}
terrainstack <- stack(areaDEMutm,
area_slope,
area_aspect)
terrainstack #have a quick look at resulting object, which shows the number of layers and the min/max values we expect
# commands: extract() {raster}
sites_vals <- extract(terrainstack,
sites_sub_utm,
buffer = 250,
fun = mean,
sp = TRUE) # extract the mean values w/in a 250m radius around each site for each terrain variable
# commands: summary(), bwplot() {lattice}
summary(sites_vals$period)#check the sample size for each period (I've done this and manually incorporated it in the boxplot labels)
elevplot <- bwplot(areaDEM ~ period,   # Here we're writing the boxplot to an object for later use (if you just want to display it, simply run the code without writing to an object)
data = data.frame(sites_vals),
notch = TRUE,
pch = "|",
fill = "grey",
box.ratio = 0.25,
par.settings = list(
box.rectangle = list(
col = c("red","blue"))),  #to maintain a visual link to our map, we'll plot the box outlines with the same color scheme
ylab = "masl",
main="Elevation",
scales = list(x = list(labels = c("Early Iron Age\n(n = 94)",
"Gallo-Roman\n(n = 491)")),
rot=60))
elevplot  #examine the result to make sure everything is in order
#repeat for slope
slopeplot <- bwplot(slope ~ period,
data = data.frame(sites_vals),
notch = TRUE,
pch = "|",
fill = "grey",
box.ratio = 0.25,
par.settings = list(
box.rectangle = list(
col = c("red","blue"))),
ylab = "slope (degrees)",
main = "Slope",
scales = list(x = list(labels = c("Early Iron Age\n(n = 94)",
"Gallo-Roman\n(n = 491)")),
rot = 60))
# view the plot
slopeplot
#and then aspect
aspectplot <- bwplot(aspect ~ period,
data = data.frame(sites_vals),
notch = TRUE,
pch = "|",
fill = "grey",
box.ratio = 0.25,
par.settings = list(
box.rectangle = list(
col = c("red","blue"))),
ylab = "aspect (degrees)",
main = "Aspect",
scales = list(x = list(labels = c("Early Iron Age\n(n = 94)",
"Gallo-Roman\n(n = 491)")),
rot=60))
# view the plot
aspectplot
# commands: summary(), bwplot() {lattice}
summary(sites_vals$period)#check the sample size for each period (I've done this and manually incorporated it in the boxplot labels)
elevplot <- bwplot(areaDEM ~ period,   # Here we're writing the boxplot to an object for later use (if you just want to display it, simply run the code without writing to an object)
data = data.frame(sites_vals),
notch = TRUE,
pch = "|",
fill = "grey",
box.ratio = 0.25,
par.settings = list(
box.rectangle = list(
col = c("red","blue"))),  #to maintain a visual link to our map, we'll plot the box outlines with the same color scheme
ylab = "masl",
main="Elevation",
scales = list(x = list(labels = c("Early Iron Age\n(n = 94)",
"Gallo-Roman\n(n = 491)")),
rot=60))
elevplot  #examine the result to make sure everything is in order
#repeat for slope
slopeplot <- bwplot(slope ~ period,
data = data.frame(sites_vals),
notch = TRUE,
pch = "|",
fill = "grey",
box.ratio = 0.25,
par.settings = list(
box.rectangle = list(
col = c("red","blue"))),
ylab = "slope (degrees)",
main = "Slope",
scales = list(x = list(labels = c("Early Iron Age\n(n = 94)",
"Gallo-Roman\n(n = 491)")),
rot = 60))
# view the plot
slopeplot
#and then aspect
aspectplot <- bwplot(aspect ~ period,
data = data.frame(sites_vals),
notch = TRUE,
pch = "|",
fill = "grey",
box.ratio = 0.25,
par.settings = list(
box.rectangle = list(
col = c("red","blue"))),
ylab = "aspect (degrees)",
main = "Aspect",
scales = list(x = list(labels = c("Early Iron Age\n(n = 94)",
"Gallo-Roman\n(n = 491)")),
rot=60))
# view the plot
aspectplot
elevplot
slopeplot
aspectplot
# a bonus plotting problem: putting all three of these in one plot
#commands: grid.arrange {gridExtra}
require(gridExtra)
grid.arrange(elevplot,
slopeplot,
aspectplot,
nrow = 1,
ncol = 3)
